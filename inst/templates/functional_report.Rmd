---
author: "Fernando Moreno Jabato"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    fig_width: 12
---

<style type='text/css'>
    body .main-container {
        max-width: 90%;

    }

    .plot_real_size {
    	overflow: scroll;
  		max-height: 600px;
  	}

    .plot_real_size img{
    	max-width: none;
    	max-height: none;
    }

    embed {
   
  }   
</style>

```{r config, include = FALSE}
 
# Load necessary packages
require(ggplot2)
require(knitr)
require(clusterProfiler)
require(enrichplot)
require(DT)

# Prepare recursive text
chunks <- function(code, options = ""){paste(paste("```{r ",options,"}",sep = ""),code,"```",sep="\n")}
render <- function(text){paste(knitr::knit(text = paste(text,collapse = "\n")),collapse = "\n")}

# Prepare all HPO reports container
out <- NULL

# Load necessary functions
if("ExpHunterSuite" %in% (.packages())){ # Package mode, load private functions
	exists_graph_file <- ExpHunterSuite:::exists_graph_file
	exists_enrich_df <- ExpHunterSuite:::exists_enrich_df
	check_results <- ExpHunterSuite:::check_results
	set_default_width <- ExpHunterSuite:::set_default_width
	plot_in_div <- ExpHunterSuite:::plot_in_div
	get_genes <- ExpHunterSuite:::get_genes
	check_categories <- ExpHunterSuite:::check_categories
	calc_width <- ExpHunterSuite:::calc_width
	calc_height <- ExpHunterSuite:::calc_height
	get_categories <- ExpHunterSuite:::get_categories
}

```




# **DEgenes Hunter - Functional analysis report** 


## **Used data in this analysis**
Specifically, in this experiment set, known experiment labels are:

`r paste(knitr::knit(text = paste(sample_classes, collapse = "\n")), collapse = "\n")`

## **General description**
This report contains all the functional information that was requested by the options when functional_Hunter.R was executed.
The functional categories can be:

* KEGG pathways
* GO:
	+ Biological Process
	+ Molecular Function
	+ Cellular Component
* Reactome pathways
* Custom nomenclature

All the functional categories are computed with CluterProfiler and GO caterogires are computed also with TopGo.
Some sections will not show if there are not sinficative results. Each category is analysed using Over representation analysis (ORA) and Gene Set Analysis (GSEA).
The ORA method takes a group of significative DEGs (only DEGs, upregulated DEGs or downregulated DEGs) and performs a hypergeometric test for each term of the selected functional category.
In the case of the GSEA method, all the genes are sorted by their fold-change and the algorithm scan which genes with similar fold-change shares a term of the selected functional category.


Statistics about input results obtained from DEGenes Expression Hunter are:
```{r table_exp_flags, echo = FALSE}
cl_table <- as.data.frame(table(DEGH_results$genes_tag))
names(cl_table) <- c("Gene_tag","Genes")
knitr::kable(cl_table)
# knitr::kable(table(DEGH_results$genes_tag))
```

```{r table_top_genes, echo = FALSE, results = 'asis'}

# Prepare regular data
targetcols <- intersect(c("rif1","rif2","diffK","diff_cn"),colnames(DEGH_results))

targetindexes <- lapply(targetcols,function(tcol){
	# Sort column
	csorted <- sort(DEGH_results[,tcol], decreasing = TRUE)
	# Take tops
	top15 <- head(csorted,15)
	bot15 <- tail(csorted,15)
	# Find
	topindx <- which(DEGH_results[,tcol] %in% top15)
	botindx <- which(DEGH_results[,tcol] %in% bot15)
	# Retrun
	return(list(top = topindx, bot = botindx))
})
# Prepare pattern based data
patterncols <- colnames(DEGH_results)[grepl("^logFC",colnames(DEGH_results))]
patternindexes <- lapply(patterncols,function(pcol){
	# Filter
	to_remove <- which(DEGH_results[,gsub("logFC","FDR",pcol)] > degh_exp_threshold)
	# Sort column
	if(length(to_remove) > 0){
		csorted <- sort(DEGH_results[-to_remove,pcol], decreasing = TRUE)
	}else{
		csorted <- sort(DEGH_results[,pcol], decreasing = TRUE)		
	}
	# Take tops
	top15 <- head(csorted,15)
	bot15 <- tail(csorted,15)
	# Find
	topindx <- setdiff(which(DEGH_results[,pcol] %in% top15),to_remove)
	botindx <- setdiff(which(DEGH_results[,pcol] %in% bot15),to_remove)

	# Retrun
	return(list(top = topindx, bot = botindx))
})
# Add special case
	# Filter
	to_remove <- which(DEGH_results[,"combined_FDR"] > degh_exp_threshold)
	# Sort column
	if(length(to_remove) > 0){
		csorted <- sort(DEGH_results[-to_remove,"mean_logFCs"], decreasing = TRUE)
	}else{
		csorted <- sort(DEGH_results[,"mean_logFCs"], decreasing = TRUE)		
	}
	# Take tops
	top15 <- head(csorted,15)
	bot15 <- tail(csorted,15)
	# Find
	topindx <- setdiff(which(DEGH_results[,"mean_logFCs"] %in% top15),to_remove)
	botindx <- setdiff(which(DEGH_results[,"mean_logFCs"] %in% bot15),to_remove)
patternindexes[[length(patternindexes)+1]] <- list(top = topindx, bot = botindx)
# Take data
topindx <- unique(unlist(lapply(seq_along(targetindexes),function(i){targetindexes[[i]]$top})))
topindx <- unique(c(topindx,unlist(lapply(seq_along(patternindexes),function(i){patternindexes[[i]]$top}))))
botindx <- unique(unlist(lapply(seq_along(targetindexes),function(i){targetindexes[[i]]$bot})))
botindx <- unique(c(botindx,unlist(lapply(seq_along(patternindexes),function(i){patternindexes[[i]]$bot}))))
# Take targets
topgenes <- DEGH_results[topindx,c("Symbol",targetcols,patterncols,"mean_logFCs",colnames(DEGH_results)[1])]
botgenes <- DEGH_results[botindx,c("Symbol",targetcols,patterncols,"mean_logFCs",colnames(DEGH_results)[1])]
# Sort

# Message
cat("## **Top genes**\n")
cat(paste(c("Table of signifcant genes. Variables taken into account are being shown into table (except gene symbols/ID). Top of positive (",nrow(topgenes)," items) and negative (",nrow(botgenes)," items) are being shown in two different tables\n"), collapse = ""))

```
```{r render_topgenes, echo = FALSE, results = 'asis'}
cat("\n### **Top positive**\n")
# Render
DT::datatable(topgenes, filter = 'top', rownames = FALSE, extensions = c('Buttons','ColReorder'),
                    options = list(
                    	colReorder = TRUE,
                    	dom = 'lftBip',
                        buttons = c('copy', 'csv', 'excel')
                    ))
```
```{r render_botgenes, echo = FALSE, results = 'asis'}
cat("\n### **Top negative**\n")
# Render
DT::datatable(botgenes, filter = 'top', rownames = FALSE, extensions = c('Buttons','ColReorder'),
                    options = list(
                    	colReorder = TRUE,
                    	dom = 'lftBip',
                        buttons = c('copy', 'csv', 'excel')
                    ))

```



```{r check_graphs_setup, echo = FALSE}
####################################### GO
n_category <- 30
# Useful_functions


```
```{r check_graphs_go, echo = FALSE}
######################################################### GO
# Prepare containers 
go_flags <- list()
go_files <- list()

# Define files to be checked
go_enrich_vars <- c("enrich_go","enrich_go_gsea")
graph_files <- c("GO_preval","GO_preval_overex","GO_preval_underex",
				"GO_allpos","GO_allpos_overex","GO_allpos_underex")
go_subontos <- c("BP","MF","CC")
graph_files <- apply(expand.grid(graph_files, go_subontos), 1, paste, collapse="_")

# Check all files
invisible(lapply(graph_files,function(file_name){
	if(exists_graph_file(path = results_path, file_name = file_name)){
		go_flags[file_name] <<- TRUE
		go_files[file_name] <<- graph_file_name(path = results_path,file_name = file_name)
	}else{
		go_flags[file_name] <<- FALSE
	}
}))
# Check GO section
go_flags$GO_SECTION <- any(unlist(go_flags))
# Add CL graphs
invisible(lapply(go_enrich_vars,function(var_name){
	go_flags[var_name] <<- exists_enrich_df(var_name)
}))
# Check GO section
# go_flags$GO_CL_SECTION <- any(unlist(go_flags[go_enrich_vars]))
go_flags$GO_CL_SECTION <- any(unlist(go_flags[go_enrich_vars]))

if(go_flags$GO_CL_SECTION){
	#check GO enrichment object
	if(go_flags$enrich_go){
		go_main_enrich <- enrich_go
	}else if(go_flags$enrich_go_gsea){
		go_main_enrich <- enrich_go_gsea
	}else if(exists("enrich_go")){
		go_main_enrich <- enrich_go	
	}else if(exists("enrich_go_gsea")){
		go_main_enrich <- enrich_go_gsea
	}

	for (onto in names(go_main_enrich)) {
		go_flags[paste0("perform_ora_go_",onto)] <- FALSE
		go_flags[paste0("perform_gsea_go_",onto)] <- FALSE #TODO Estas variables se tienen que inicializar como false para que no rompan las logicas posteriores. 
		if(go_flags$enrich_go){
			go_flags[paste0("perform_ora_go_",onto)] <- check_results(enrich_go[[onto]])
		}else if(go_flags$enrich_go_gsea){
			go_flags[paste0("perform_gsea_go_",onto)] <- check_results(enrich_go_gsea[[onto]])
		}
	}
}

```
```{r check_graphs_kegg, echo = FALSE}
####################################### KEGG

# Prepare containers
kegg_flags <- list()

# Define variables to be checked
kegg_enrich_vars <- c("enrich_ora","enrich_gsea")

# Check all variables
invisible(lapply(kegg_enrich_vars,function(var_name){
	kegg_flags[var_name] <<- exists_enrich_df(var_name)
}))

#kegg_flags$KEGG_SECTION <- any(unlist(kegg_flags))
kegg_flags$KEGG_SECTION <- any(unlist(lapply(kegg_enrich_vars, function(var){exists(var)})))

```
```{r check_graphs_react, echo = FALSE}
####################################### REACTOME

# Prepare containers
react_flags <- list()

# Define variables to be checked
react_enrich_vars <- c("enrich_react","enrich_react_gsea")

# Check all variables
invisible(lapply(react_enrich_vars,function(var_name){
	react_flags[var_name] <<- exists_enrich_df(var_name)
}))

#react_flags$REACT_SECTION <- any(unlist(react_flags))
react_flags$REACT_SECTION <- any(unlist(lapply(react_enrich_vars, function(var){exists(var)})))

```
```{r check_graphs_custom, echo = FALSE}
####################################### CUSTOM

if(!is.null(custom_enrichments)){
	# Prepare containers
	custom_flags <- list()

	# Check all variables
	invisible(lapply(seq_along(custom_enrichments),function(i){
		custom_flags[names(custom_enrichments)[i]] <<- check_results(custom_enrichments[[i]])
	}))

	custom_flags$CUSTOM_SECTION <- any(unlist(custom_flags))
}else{
	custom_flags <- list(CUSTOM_SECTION = FALSE)
}

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
```
```{r setup_plots, echo=FALSE, eval = FALSE}
# if(kegg_flags[["enrich_ora"]] | kegg_flags[["enrich_gsea"]] |
# 	go_flags[["enrich_go"]] | go_flags[["enrich_go_gsea"]] |
# 	react_flags[["enrich_react"]] | react_flags[["enrich_react_gsea"]]){
	# suppressPackageStartupMessages(require(clusterProfiler))
	# suppressPackageStartupMessages(require(enrichplot))
# }


```
























```{r kegg_main,  results='asis', echo = FALSE, eval = flags$KEGG}
cat("## **KEGG analysis**\n")

# Check special case
if(!kegg_flags$enrich_ora & !kegg_flags$enrich_gsea){
	cat(paste("This ontology study has been executed but **has not returned any result**\n",sep=""))
}
```

```{r kegg_ora, results='asis', echo = FALSE, eval = kegg_flags$enrich_ora, message=FALSE, warning=FALSE}

default_width <- set_default_width(enrich_obj = enrich_ora, showCategory=n_category)
# Main label 
cat("### **Over Representation Analysis**\n",
	"The ORA method takes a group of significative DEGs (only DEGs, upregulated DEGs or downregulated DEGs) and performs a hypergeometric test for each term of the selected functional category.\n\n")

cat(
	"**Barplot**\n\n", 
	"The plot shows the functional top significative terms in ascendant order by adjusted pvalue. The color represents the associated adjusted pvalue. 
	The X axis represents the proportion of the known genes for a given functional term that are identified in the expression data.\n\n"
)
pp <- graphics::barplot(enrich_ora, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)




cat("\n\n**Dotplot**\n\n",
	"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
	The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
)
pp <- enrichplot::dotplot(enrich_ora, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)



cat("\n\n**Gene-Concept Network**\n\n", 
	"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
	The size of the functional terms shows the number of connected genes.\n\n"
)
enrich_ora_symb <- DOSE::setReadable(enrich_ora, OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")

if(length(get_genes(enrich_ora_symb)) <= 200){
	pp <- enrichplot::cnetplot(enrich_ora_symb, showCategory=n_category, foldChange=geneList) +
		  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
	plot_in_div(pp, fig_width = default_width)
}else{
	cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
}

cat("\n\n**Enrich Map plot**\n\n", 
	"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
	The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
)
if (check_categories(enrich_ora, min_categories = 1)) {
	pp <- enrichplot::emapplot(enrich_ora, showCategory=n_category)
	plot_in_div(pp, fig_width = default_width)
} else {
	cat("\nThis graph can not be plotted because only one functional category was enriched\n")
}


cat("\n\n**Heatplot**\n\n", 
	"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
)

pp <- enrichplot::heatplot(enrich_ora_symb, showCategory=n_category, foldChange=geneList)
width_size <- calc_width(enrich_ora_symb)
height_size <- calc_height(enrich_ora_symb) 

plot_in_div(pp, height_size, width_size)

cat("\n\n**Upsetplot**\n\n", 
	"Top functional terms are listed the Y axis with the number of genes associated to them (Set size). Each column of dots marks one cluster of functional terms. The X axis indicates how many genes are shared exclusively for the members of one cluster.\n\n"
)
if(length(get_categories(enrich_ora))>=2){ # Needs, at least, two categories
	pp <- enrichplot::upsetplot(enrich_ora, n=n_category)
	plot_in_div(pp, fig_width = default_width)
}else{
	cat("\n\nGenes has been enriched in less than 2 categories, so Upsetplot cannot be printed\n\n")
}
```







```{r kegg_gsea, results='asis', echo = FALSE, eval = kegg_flags$enrich_gsea, message=FALSE}
default_width <- set_default_width(enrich_obj = enrich_gsea, showCategory=n_category)

# Main label
cat("\n\n### **Gene Set Enrichment Analysis**\n",
	"In this method, all the genes are sorted by their fold-change and the algorithm scan which genes with similar fold-change shares a term of the selected functional category.\n\n"
)

cat("\n\n**Dotplot**\n\n",
	"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
	The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
)
pp <- enrichplot::dotplot(enrich_gsea, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)


cat("\n\n**Gene-Concept Network**\n\n", 
	"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
	The size of the functional terms shows the number of connected genes.\n\n"
)
enrich_gsea_symb <- DOSE::setReadable(enrich_gsea, OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")
if(length(get_genes(enrich_gsea_symb)) <= 200){
	pp <- enrichplot::cnetplot(enrich_gsea_symb, showCategory=n_category, foldChange=geneList) +
		  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
	plot_in_div(pp, fig_width = default_width)
}else{
	cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
}

cat("\n\n**Enrich Map plot**\n\n", 
	"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
	The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
)
if (check_categories(enrich_gsea, min_categories = 1)) {
	pp <- enrichplot::emapplot(enrich_gsea, showCategory=n_category)
	plot_in_div(pp, fig_width = default_width)
} else {
	cat("\nThis graph can not be plotted because only one functional category was enriched\n")
}

cat("\n\n**Heatplot**\n\n", 
	"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
)

pp <- enrichplot::heatplot(enrich_gsea_symb, showCategory=n_category, foldChange=geneList)
width_size <- calc_width(enrich_gsea_symb)
height_size <- calc_height(enrich_gsea_symb) 
plot_in_div(pp, height_size, width_size)


cat("\n\n**Ridgeplot**\n\n",
	"Top functional terms are show in the Y axis and for each one of them a fold-change distribution is shown.
	The distribution colours indicates the adjusted pvalue.\n\n"
)
pp <- enrichplot::ridgeplot(enrich_gsea, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)


cat("\n\n**Rank plot**\n\n", 
	"The enrichment score evolution trought the ranked genes by fold-change are show for the top functional terms. 
	Y axis shows the enrichment score and the X axis shows the genes ranked by fold-change.\n\n"
)
pp <- enrichplot::gseaplot2(enrich_gsea, geneSetID=ifelse(nrow(enrich_gsea@result) < 4, seq(nrow(enrich_gsea@result)), 1:4), title = enrich_gsea$Description[1], pvalue_table = TRUE)

plot_in_div(pp, fig_width = default_width)


```




```{r display_kegg_res, results='asis', echo = FALSE, eval = kegg_flags$enrich_ora}

cat("## **ClusterProfiler KEGG table**\n\n", "Detailed table with the data obtained from KEGG pathways (ORA method only). For each pathway, the identifier, link to KEGG DB with the detected genes, name, adjusted pvalue and genes (count and ids)")


# Add kegg table
kegg_df <- as.data.frame(enrich_ora_symb)
kegg_df[,1] <- unlist(lapply(enrich_ora_symb[,1],function(id){
	link <- url <- paste0("http://www.kegg.jp/kegg-bin/show_pathway?", id, "/default%3dorange/", enrich_ora_symb[id, "geneID"]) # browseKEGG(enrich_ora, id)
	to_html <- paste0("[",id,"](",link,")")
	# to_HTML <- paste("<a href='",link,"'>",id,"</a>",sep="")
}))

cols_to_show <- c("ID","Description","p.adjust","Count","geneID")
knitr::kable(kegg_df[,cols_to_show])
```




















```{r display_go_main, results='asis', echo = FALSE, eval = flags$GO_cp}
cat("## **GO Analysis**\n")

if(!go_flags$GO_CL_SECTION){	
		cat(paste("**Any sub-ontology has returned results** on this study.\n\n",sep=""))
}
```


```{r plot_go_cl, results='asis', echo = FALSE, eval = go_flags$GO_CL_SECTION, message=FALSE, warning=FALSE}

# Plots per sub-ontology
for (onto in names(go_main_enrich)) {
	# names(go_main_enrich)
	# for(onto in names(enrich_go)){
	
	# Special case
	if(!go_flags$enrich_go & !go_flags$enrich_go_gsea){	
		cat(paste("### **[",onto,"] GO Analysis**<br>\nThis sub-ontology study has been executed but **has not returned any result**\n\n",sep=""))
	}
	# else if(nrow(go_main_enrich[[onto]]@result[which(go_main_enrich@result$p.adjust <= go_main_enrich@pvalueCutoff),]) <= 0){
	# 	cat(paste("### **[",onto,"] GO Analysis**<br>This sub-ontology study has been executed but **has not returned any result**\n",sep=""))
	# }


	message(go_flags)
	##################################################### ORA PLOTS
	if(go_flags[[paste0("perform_ora_go_",onto)]]){
		default_width <- set_default_width(enrich_obj = enrich_go[[onto]], showCategory=n_category)

		# Add main label
		cat(paste("### **[",onto,"] Over Representation Analysis** \n",sep=""),
			"The ORA method takes a group of significative DEGs (only DEGs, upregulated DEGs or downregulated DEGs) and performs a hypergeometric test for each term of the selected functional category.\n\n"
		)

		cat(
			"**Barplot**\n\n", 
			"The plot shows the functional top significative terms in ascendant order by adjusted pvalue. The color represents the associated adjusted pvalue. 
			The X axis represents the proportion of the known genes for a given functional term that are identified in the expression data.\n\n"
		)
		go_pp <- graphics::barplot(enrich_go[[onto]], showCategory=n_category)
		plot_in_div(go_pp, fig_width = default_width)

		
		cat("\n\n**Dotplot**\n\n",
			"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
			The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
		)
		go_pp <- enrichplot::dotplot(enrich_go[[onto]], showCategory=n_category)
		plot_in_div(go_pp, fig_width = default_width)

		cat("\n\n**Gene-Concept Network**\n\n", 
			"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
			The size of the functional terms shows the number of connected genes.\n\n"
		)
		enrich_go_ora_symb <- DOSE::setReadable(enrich_go[[onto]], OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")

		if(length(get_genes(enrich_go_ora_symb)) <= 200){
			go_pp <- enrichplot::cnetplot(enrich_go_ora_symb, showCategory=n_category, foldChange=geneList) +
					 ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
			plot_in_div(go_pp, fig_width = default_width)
		}else{
			cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
		}

		cat("\n\n**Enrich Map plot**\n\n", 
			"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
			The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
		)
		if (check_categories(enrich_go[[onto]], min_categories = 1)) {
			go_pp <- enrichplot::emapplot(enrich_go[[onto]], showCategory=n_category)
			plot_in_div(go_pp, fig_width = default_width)
		} else {
			cat("\nThis graph can not be plotted because only one functional category was enriched\n")
		}
		cat("\n\n**Heatplot**\n\n", 
			"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
		)
		go_pp <- enrichplot::heatplot(enrich_go_ora_symb, showCategory=n_category, foldChange=geneList)
		width_size <- calc_width(enrich_go_ora_symb)
		height_size <- calc_height(enrich_go_ora_symb) 
		plot_in_div(go_pp, height_size, width_size)

		cat("\n\n**Upsetplot**\n\n", 
			"Top functional terms are listed the Y axis with the number of genes associated to them (Set size). Each column of dots marks one cluster of functional terms. The X axis indicates how many genes are shared exclusively for the members of one cluster.\n\n"
		)
		if(length(get_categories(enrich_go[[onto]]))>=2){ # Needs, at least, two categories
			go_pp <- enrichplot::upsetplot(enrich_go[[onto]], n=n_category)
			plot_in_div(go_pp, fig_width = default_width)
			cat("\n \n")
		}else{
			cat("\n\nGenes has been enriched in less than 2 categories, so Upsetplot cannot be printed\n\n")
		}
	}



	###################################################### GSEA PLOTS
	if(go_flags[[paste0("perform_gsea_go_",onto)]]){
		# Add main label
		default_width <- set_default_width(enrich_obj = enrich_go_gsea[[onto]], showCategory=n_category)

		cat(paste("\n\n### **[",onto,"]Gene Set Enrichment Analysis**\n",sep=""),
			"In this method, all the genes are sorted by their fold-change and the algorithm scan which genes with similar fold-change shares a term of the selected functional category.\n\n"
		)

		cat("\n\n**Dotplot**\n\n",
			"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
			The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
		)
		go_pp <- enrichplot::dotplot(enrich_go_gsea[[onto]], showCategory=n_category)
		plot_in_div(go_pp, fig_width = default_width)

		cat("\n\n**Gene-Concept Network**\n\n", 
			"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
			The size of the functional terms shows the number of connected genes.\n\n"
		)
		enrich_go_gsea_symb <- DOSE::setReadable(enrich_go_gsea[[onto]], OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")

		if(length(get_genes(enrich_go_gsea_symb)) <= 200){
			go_pp <- enrichplot::cnetplot(enrich_go_gsea_symb, showCategory=n_category, foldChange=geneList) +
					  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
			plot_in_div(go_pp, fig_width = default_width)
		}else{
			cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
		}

		cat("\n\n**Enrich Map plot**\n\n", 
			"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
			The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
		)
		if (check_categories(enrich_go_gsea[[onto]], min_categories = 1)) {
			go_pp <- enrichplot::emapplot(enrich_go_gsea[[onto]], showCategory=n_category)
			plot_in_div(go_pp, fig_width = default_width)
		} else {
			cat("\nThis graph can not be plotted because only one functional category was enriched\n")
		}
		cat("\n\n**Heatplot**\n\n", 
			"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
		)
		go_pp <- enrichplot::heatplot(enrich_go_gsea_symb, showCategory=n_category, foldChange=geneList)
		width_size <- calc_width(enrich_go_gsea_symb)
		height_size <- calc_height(enrich_go_gsea_symb) 
		save(enrich_go_gsea_symb, file = "enrich_go_gsea_symb.Rdata")
		plot_in_div(go_pp, height_size, width_size)

		cat("\n\n**Ridgeplot**\n\n",
			"Top functional terms are show in the Y axis and for each one of them a fold-change distribution is shown.
			The distribution colours indicates the adjusted pvalue.\n\n"
		)
		go_pp <- enrichplot::ridgeplot(enrich_go_gsea[[onto]], showCategory=n_category)
		plot_in_div(go_pp, fig_width = default_width)

		cat("\n\n**Rank plot**\n\n", 
			"The enrichment score evolution trought the ranked genes by fold-change are show for the top functional terms. 
			Y axis shows the enrichment score and the X axis shows the genes ranked by fold-change.\n\n"
		)
		go_pp <- enrichplot::gseaplot2(enrich_go_gsea[[onto]], geneSetID=ifelse(nrow(enrich_go_gsea[[onto]]@result) < 4, seq(nrow(enrich_go_gsea[[onto]]@result)), 1:4), pvalue_table = TRUE) 
		plot_in_div(go_pp, fig_width = default_width)
		cat("\n \n")
	}
}
# }
```

```{r plot_go_cl_ora, results='asis', echo = FALSE, eval = FALSE, message=FALSE, warning=FALSE}
# TODO : all is not being genrated now
#{r plot_go_cl_ora, results='asis', echo = FALSE, eval = go_flags$GO_CL_SECTION, message=FALSE, warning=FALSE}

if(go_flags$enrich_go){
	# message("PLOTS SETS ALL UNIFIED")
	cat("### **[All] Over Representation Analysis Unified**  \n\n",
		"This category will aggregate the results for all the selected GO ontologies\n\n"
		)
	# Concat results
	enr_go <- enrich_go[[1]]
	default_width <- set_default_width(enrich_obj = enr_go, showCategory=n_category)
	if(length(enrich_go)>1){
		invisible(lapply(seq_along(enrich_go)[-1],function(i){
			enr_go@result <<- rbind(enr_go@result, enrich_go[[i]]@result)
		}))
		# Sort
		enr_go@result <- enr_go@result[order(enr_go@result$p.adjust),]
	}

	# Plot
	cat(
		"**Barplot**\n\n", 
		"The plot shows the functional top significative terms in ascendant order by adjusted pvalue. The color represents the associated adjusted pvalue. 
		The X axis represents the proportion of the known genes for a given functional term that are identified in the expression data.\n\n"
	)
	go_pp  <- graphics::barplot(enr_go, showCategory=n_category)
	plot_in_div(go_pp, fig_width = default_width)

	cat("\n\n**Dotplot**\n\n",
		"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
		The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
	)
	go_pp  <- enrichplot::dotplot(enr_go, showCategory=n_category)
	plot_in_div(go_pp, fig_width = default_width)

	cat("\n\n**Gene-Concept Network**\n\n", 
		"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
		The size of the functional terms shows the number of connected genes.\n\n"
	)
	enr_go_symb <- DOSE::setReadable(enr_go, OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")
	if(length(get_genes(enr_go_symb)) <= 200){
		go_pp  <- enrichplot::cnetplot(enr_go_symb, showCategory=n_category, foldChange=geneList) +
				  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
		plot_in_div(go_pp, fig_width = default_width)
	}else{
		cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
	}
	
	cat("\n\n**Enrich Map plot**\n\n", 
		"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
		The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
	)
	if (check_categories(enr_go, min_categories = 1)) {
		go_pp  <- enrichplot::emapplot(enr_go, showCategory=n_category)
		plot_in_div(go_pp, fig_width = default_width)
	} else {
		cat("\nThis graph can not be plotted because only one functional category was enriched\n")
	}

	cat("\n\n**Heatplot**\n\n", 
		"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
	)
	go_pp  <- enrichplot::heatplot(enr_go_symb, showCategory=n_category, foldChange=geneList)
	width_size <- calc_width(enr_go_symb)
	height_size <- calc_height(enr_go_symb) 
	plot_in_div(go_pp, height_size, width_size)

	cat("\n\n**Upsetplot**\n\n", 
		"Top functional terms are listed the Y axis with the number of genes associated to them (Set size). Each column of dots marks one cluster of functional terms. The X axis indicates how many genes are shared exclusively for the members of one cluster.\n\n"
	)
	if(length(get_categories(enr_go))>=2){ # Needs, at least, two categories
		go_pp <- enrichplot::upsetplot(enr_go, n=n_category)
		plot_in_div(go_pp, fig_width = default_width)
	}else{
		cat("\n\nGenes has been enriched in less than 2 categories, so Upsetplot cannot be printed\n\n")
	}
	cat("\n \n")
}

```

```{r plot_go_cl_gsea, results='asis', echo = FALSE, eval = FALSE, message=FALSE, warning=FALSE}
# TODO : all is not being genrated now
# {r plot_go_cl_gsea, results='asis', echo = FALSE, eval = go_flags$GO_CL_SECTION, message=FALSE, warning=FALSE}

if(go_flags$enrich_go_gsea){
	# message("PLOTS SETS ALL UNIFIED")
	cat("### **[All] Gene Set Expression Analysis Unified**  \n\n",
		"This category will aggregate the results for all the selected GO ontologies\n\n"
	)
	# Concat results
	enr_go_gsea <- enrich_go_gsea[[1]]
	default_width <- set_default_width(enrich_obj = enr_go_gsea, showCategory=n_category)

	if(length(enrich_go_gsea)>1){
		invisible(lapply(seq_along(enrich_go_gsea)[-1],function(i){
			enr_go_gsea@result <<- rbind(enr_go_gsea@result, enrich_go_gsea[[i]]@result)
		}))
		# Sort
		enr_go_gsea@result <- enr_go_gsea@result[order(enr_go_gsea@result$p.adjust),]
	}

	cat("\n\n**Dotplot**\n\n",
		"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
		The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
	)
	go_pp <- enrichplot::dotplot(enr_go_gsea, showCategory=n_category)
	plot_in_div(go_pp, fig_width = default_width)

	cat("\n\n**Gene-Concept Network**\n\n", 
		"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
		The size of the functional terms shows the number of connected genes.\n\n"
	)
	enr_go_gsea_symb <- DOSE::setReadable(enr_go_gsea, OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")
	if(length(get_genes(enr_go_gsea_symb)) <= 200){
		go_pp <- enrichplot::cnetplot(enr_go_gsea_symb, showCategory=n_category, foldChange=geneList) +
				  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
		plot_in_div(go_pp, fig_width = default_width)
	}else{
		cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
	}
	cat("\n\n**Enrich Map plot**\n\n", 
		"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
		The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
	)
	if (check_categories(enr_go_gsea, min_categories = 1)) {
		go_pp <- enrichplot::emapplot(enr_go_gsea, showCategory=n_category)
		plot_in_div(go_pp, fig_width = default_width)
	} else {
		cat("\nThis graph can not be plotted because only one functional category was enriched\n")
	}
	cat("\n\n**Heatplot**\n\n", 
		"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
	)
	go_pp <- enrichplot::heatplot(enr_go_gsea_symb, showCategory=n_category, foldChange=geneList)
	width_size <- calc_width(enr_go_gsea_symb)
	height_size <- calc_height(enr_go_gsea_symb)

	plot_in_div(go_pp, height_size, width_size)
	
	cat("\n\n**Ridgeplot**\n\n",
		"Top functional terms are show in the Y axis and for each one of them a fold-change distribution is shown.
		The distribution colours indicates the adjusted pvalue.\n\n"
	)
	go_pp <- enrichplot::ridgeplot(enr_go_gsea, showCategory=n_category)
	plot_in_div(go_pp, fig_width = default_width)
	cat("\n \n")
}


```



```{r go_section, echo = FALSE}
# Prepare text to be rendered
headers <- list(GO_preval = "### **GO Prevalent DEGs:",
				GO_preval_overex = "### **GO Overexpressed functions from prevalent DEGs:",
				GO_preval_underex = "### **GO Underexpressed functions from prevalent DEGs:",
				GO_allpos = "### **GO All possible DEGs:",
				GO_allpos_overex = "### **GO Overexpressed functions from all possible DEGs:",
				GO_allpos_underex = "### **GO Underexpressed functions from all possible DEGs:")
bodies  <- list(GO_preval = "This is the GO graph concerning prevalent DEGs",
				GO_preval_overex = "This is the GO graph concerning the overexpressed prevalent DEGs:",
				GO_preval_underex = "This is the GO graph concerning the underexpressed prevalent DEGs:",
				GO_allpos = "This is the GO graph concerning all possible DEGs",
				GO_allpos_overex = "This is the GO graph concerning the overexpressed all possible DEGs:",
				GO_allpos_underex = "This is the GO graph concerning the underexpressed all possible DEGs")
ontos   <- list(BP = "Biological Process (BP)**",
				MF = "Molecular Function (MF)**",
				CC = "Cellular Component (CC)**")

if(!go_flags$GO_SECTION){
	out <- ""
}else{
	################## CHECK FIFLE BY FILE
	out <- unlist(lapply(graph_files,function(f){
		if(go_flags[[f]]){
			# Prepare file info
			splitted <- unlist(strsplit(f,"_"))
			basename <- paste(head(splitted,-1),collapse="_")
			# prepare render info
			header <- headers[[basename]] 
			body <- bodies[[basename]]
			onto <- ontos[[tail(splitted,1)]]
			label <- paste(header,onto,sep=" ")[1]
			# Paste and return
			return(knitr::knit_expand(text = paste(label,
											body,
											"<br>",
											chunks(code = paste("knitr::include_graphics('",go_files[[f]],"')"),
												   options = "echo = FALSE"),
											"\n",sep = "\n")))
		}else{
			return("")
		}
	}))

	# Add section header
	out <- c(knitr::knit_expand(text = "## **GO graphs**"),out)
}
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
```

`r paste(knitr::knit(text = paste(out,collapse = "\n")),collapse = "\n")`







```{r react_main,  results='asis', echo = FALSE, eval = flags$REACT}
cat("## **REACTOME analysis**\n")

# Check special case
if(!react_flags$enrich_react & !react_flags$enrich_react_gsea){
	cat(paste("This ontology study has been executed but **has not returned any result**\n",sep=""))
}
```

```{r react_ora, results='asis', echo = FALSE, eval = react_flags$enrich_react, message=FALSE, warning=FALSE}
default_width <- set_default_width(enrich_obj = enrich_react, showCategory=n_category)

# Main label 
cat("### **Over Representation Analysis**\n",
	"The ORA method takes a group of significative DEGs (only DEGs, upregulated DEGs or downregulated DEGs) and performs a hypergeometric test for each term of the selected functional category.\n\n")

cat(
	"**Barplot**\n\n", 
	"The plot shows the functional top significative terms in ascendant order by adjusted pvalue. The color represents the associated adjusted pvalue. 
	The X axis represents the proportion of the known genes for a given functional term that are identified in the expression data.\n\n"
)
pp <- graphics::barplot(enrich_react, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)



cat("\n\n**Dotplot**\n\n",
	"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
	The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
)
pp <- enrichplot::dotplot(enrich_react, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)



cat("\n\n**Gene-Concept Network**\n\n", 
	"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
	The size of the functional terms shows the number of connected genes.\n\n"
)
enrich_react_symb <- DOSE::setReadable(enrich_react, OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")
if(length(get_genes(enrich_react_symb)) <= 200){
	pp <- enrichplot::cnetplot(enrich_react_symb, showCategory=n_category, foldChange=geneList) +
		  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
	plot_in_div(pp, fig_width = default_width)
}else{
	cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
}


cat("\n\n**Enrich Map plot**\n\n", 
	"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
	The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
)
if (check_categories(enrich_react, min_categories = 1)) {
	pp <- enrichplot::emapplot(enrich_react, showCategory=n_category)
	plot_in_div(pp, fig_width = default_width)
} else {
	cat("\nThis graph can not be plotted because only one functional category was enriched\n")
}


cat("\n\n**Heatplot**\n\n", 
	"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
)
pp <- enrichplot::heatplot(enrich_react_symb, showCategory=n_category, foldChange=geneList)
width_size <- calc_width(enrich_react_symb)
height_size <- calc_height(enrich_react_symb)
plot_in_div(pp, height_size, width_size)
	



cat("\n\n**Upsetplot**\n\n", 
	"Top functional terms are listed the Y axis with the number of genes associated to them (Set size). Each column of dots marks one cluster of functional terms. The X axis indicates how many genes are shared exclusively for the members of one cluster.\n\n"
)
if(length(get_categories(enrich_react))>=2){ # Needs, at least, two categories

	pp <- enrichplot::upsetplot(enrich_react, n=n_category)
	plot_in_div(pp, fig_width = default_width)
}else{
		cat("\n\nGenes has been enriched in less than 2 categories, so Upsetplot cannot be printed\n\n")
	}
```







```{r react_gsea, results='asis', echo = FALSE, eval = react_flags$enrich_react_gsea}
default_width <- set_default_width(enrich_obj = enrich_react_gsea, showCategory=n_category)
# Main label
cat("\n\n### **Gene Set Enrichment Analysis**\n",
	"In this method, all the genes are sorted by their fold-change and the algorithm scan which genes with similar fold-change shares a term of the selected functional category.\n\n"
)

cat("\n\n**Dotplot**\n\n",
	"The plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
	The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n"
)
pp <- enrichplot::dotplot(enrich_react_gsea, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)


cat("\n\n**Gene-Concept Network**\n\n", 
	"The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
	The size of the functional terms shows the number of connected genes.\n\n"
)
enrich_react_gsea_symb <- DOSE::setReadable(enrich_react_gsea, OrgDb = current_organism_info$Bioconductor_DB[1], keyType="ENTREZID")
if(length(get_genes(enrich_react_gsea_symb)) <= 200){
	pp <- enrichplot::cnetplot(enrich_react_gsea_symb, showCategory=n_category, foldChange=geneList) +
		  ggplot2::scale_color_gradient2(name = "fold change", low = "#0000BF", high = "#bf0000", na.value = "#50EA55")
	plot_in_div(pp, fig_width = default_width)
}else {
	cat("\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n")
}

cat("\n\n**Enrich Map plot**\n\n", 
	"The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
	The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n"
)
if (check_categories(enrich_react_gsea, min_categories = 1)) {
	pp <- enrichplot::emapplot(enrich_react_gsea, showCategory=n_category)
	plot_in_div(pp, fig_width = default_width)
} else {
	cat("\nThis graph can not be plotted because only one functional category was enriched\n")
}

cat("\n\n**Heatplot**\n\n", 
	"Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n"
)
pp <- enrichplot::heatplot(enrich_react_gsea_symb, showCategory=n_category, foldChange=geneList)
width_size <- calc_width(enrich_react_gsea_symb)
height_size <- calc_height(enrich_react_gsea_symb)
plot_in_div(pp, height_size, width_size)


cat("\n\n**Ridgeplot**\n\n",
	"Top functional terms are show in the Y axis and for each one of them a fold-change distribution is shown.
	The distribution colours indicates the adjusted pvalue.\n\n"
)
pp <- enrichplot::ridgeplot(enrich_react_gsea, showCategory=n_category)
plot_in_div(pp, fig_width = default_width)


cat("\n\n**Rank plot**\n\n", 
	"The enrichment score evolution trought the ranked genes by fold-change are show for the top functional terms. 
	Y axis shows the enrichment score and the X axis shows the genes ranked by fold-change.\n\n"
)
pp <- enrichplot::gseaplot2(enrich_react_gsea, geneSetID=ifelse(nrow(enrich_react_gsea@result) < 4, seq(nrow(enrich_react_gsea@result)), 1:4), title = enrich_react_gsea$Description[1], pvalue_table = TRUE)
plot_in_div(pp, fig_width = default_width)


```

```{r create_out_custom, echo = FALSE}
out_custom <- ""
```

```{r custom_create, echo = FALSE, eval = !is.null(custom_enrichments)}
out_custom <- NULL
invisible(lapply(seq_along(custom_enrichments),function(i){
	res <- custom_enrichments[[i]]
	if(!custom_flags[[names(custom_enrichments)[i]]]){
		header <- paste("## **",basename(names(custom_enrichments)[i]),"** \n\nThis CUSTOM study has been executed but **has not returned any result**\n", sep="")
		body <- ""
	}else{
		header <- ""

		# Prepare ORA plots
		body <- "enr_custom <- custom_enrichments[[{{i}}]]
				default_width <- set_default_width(enrich_obj = enr_custom, showCategory=n_category)
				
				# Header
				cat(paste('\n## **',basename(names(custom_enrichments)[{{i}}]),'**\n',sep=''))

				# Main label 
				cat('\n### **Over Representation Analysis**\n',
					'The ORA method takes a group of significative DEGs (only DEGs, upregulated DEGs or downregulated DEGs) and performs a hypergeometric test for each term of the selected functional category.\n\n')

				cat(
					'**Barplot**\n\n', 
					'The plot shows the functional top significative terms in ascendant order by adjusted pvalue. The color represents the associated adjusted pvalue. 
					The X axis represents the proportion of the known genes for a given functional term that are identified in the expression data.\n\n'
				)
				pp <- graphics::barplot(enr_custom, showCategory=n_category)
				plot_in_div(pp, fig_width = default_width)



				cat('\n\n**Dotplot**\n\n',
					'he plot shows the top functional terms in descendant order by gene ratio. This ratio is the proportion of the known genes for a given functional term that are identified in the expression data. The color represents the associated adjusted pvalue. 
					The X axis represents the gene ratio and the dot size the number of DEG genes associated to the functional term.\n\n'
				)
				pp <- enrichplot::dotplot(enr_custom, showCategory=n_category)
				plot_in_div(pp, fig_width = default_width)



				cat('\n\n**Gene-Concept Network**\n\n', 
					'The network connects the top functional terms (brown nodes) to their associated genes (grey or colored nodes).
					The size of the functional terms shows the number of connected genes.\n\n'
				)
				enr_custom <- DOSE::setReadable(enr_custom, OrgDb = current_organism_info$Bioconductor_DB[1], keyType='ENTREZID')
				if(length(get_genes(enr_custom)) <= 200){
					pp <- enrichplot::cnetplot(enr_custom, showCategory=n_category, foldChange=geneList) +
						  ggplot2::scale_color_gradient2(name = 'fold change', low = '#0000BF', high = '#bf0000', na.value = '#50EA55')
					plot_in_div(pp, fig_width = default_width)
				}else{
					cat('\n\nCnetplot is not readable because more than 200 genes has been enriched in this nomenclature, so is not printed\n\n')
				}


				cat('\n\n**Enrich Map plot**\n\n', 
					'The network connects the top functional terms (nodes) between them trought their associates genes (grey edges, thickness represents the number of shared genes.).
					The size of the functional terms shows the number of connected genes and the color the adjusted pvalue of the functional term.\n\n'
				)
				if (check_categories(enr_custom, min_categories = 1)) {
					pp <- enrichplot::emapplot(enr_custom, showCategory=n_category)
					plot_in_div(pp, fig_width = default_width)
				} else {
					cat('\nThis graph can not be plotted because only one functional category was enriched\n')
				}


				cat('\n\n**Heatplot**\n\n', 
					'Top functional terms are show in the Y axis whereas in the X axis are show the associated genes to them. The coloured squares indicates the fold change value.\n\n'
				)
				pp <- enrichplot::heatplot(enr_custom, showCategory=n_category, foldChange=geneList)
				width_size <- calc_width(enr_custom)
				height_size <- calc_height(enr_custom)
				plot_in_div(pp, height_size, width_size)
					
				cat('\n\n**Upsetplot**\n\n', 
					'Top functional terms are listed the Y axis with the number of genes associated to them (Set size). Each column of dots marks one cluster of functional terms. The X axis indicates how many genes are shared exclusively for the members of one cluster.\n\n'
				)
				if(length(get_categories(enr_custom))>=2){ # Needs, at least, two categories
					pp <- enrichplot::upsetplot(enr_custom, n=n_category)
					plot_in_div(pp, fig_width = default_width)\n
				}else{
					cat('\n\nGenes has been enriched in less than 2 categories, so Upsetplot cannot be printed\n\n')
				}


				"
	}

	body <- gsub("\\{\\{i\\}\\}",i,body)


	out_custom <<- c(out_custom,paste(knitr::knit_expand(text = paste(header,
											 					chunks(body, options = "echo = FALSE,results='asis'"),
											 					"\n",sep = "\n")),
														sep = "\n"))
}))
```

  `r paste(knitr::knit(text = paste(out_custom,collapse = "\n")),collapse = "\n")`


## **Values of options used to run Functional Hunter**
First column contains the option names; second column contains the given values for each option in this run.
```{r opt_vals, echo = FALSE}
knitr::kable(cbind(func_results$final_main_params))
```






