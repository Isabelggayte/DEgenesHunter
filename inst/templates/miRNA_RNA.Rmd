---
author: "José Córdoba Caballero"
output:
  html_document:
    toc: true
    toc_float: true
    df_print: paged
    fig_width: 12
---

<style type='text/css'>
    body .main-container { 
        max-width: 90%;
    
    }

    .plot_real_size {
      overflow: scroll;
      max-height: 600px;
    }

    .plot_real_size img{
      max-width: none;
      max-height: none;
    }

    embed {
   
  }   
</style>


# **RNAseq - miRNAseq correlation report**

```{r introduction, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}
cat(paste0("This report summarizes results from [script_name] execution comparing **", opt$RNAseq_folder, "** RNAseq data and **", opt$miRNAseq_folder, "** miRNAseq data.
 miRNAseq and RNAseq data has been correlated using different strategies and then compared with databases included in multiMiR.\n\n" ))
```


* Strategies description: 
    + counts_RNA_vs_counts_miRNA correlates normalized RNAseq counts with normalized miRNAseq counts. 
    + Eigen_RNA_v_Eigen_miRNA correlates Eigengene profile of RNAseq coexpression modules with Eigengene profile of miRNAseq coexpression modules. 
    + Eigen_RNA_v_Hub1_miRNA correlates Eigengene profile of RNAseq coexpression modules with hub gene profile of miRNAseq coexpression modules. 
    + Eigen_RNA_v_counts_miRNA correlates Eigengene profile of RNAseq coexpression modules with with normalized miRNAseq counts.
    + Hub1_RNA_v_counts_miRNA correlates hub gene profile of RNAseq coexpression modules with with normalized miRNAseq counts.
    + Hub1_RNA_v_Eigen_miRNA correlates hub gene profile of RNAseq coexpression modules with Eigengene profile of miRNAseq coexpression modules.


```{r methods_comparison_violin_cor, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}

cat("## **RNAseq and miRNAseq correlation methods comparison**")
cat("\nThis plot shows the distributions of correlations between RNAseq and miRNAseq using diferent strategies.
  \n")
min <- -0.5
if (min < corr_cutoff) {
  min <- corr_cutoff
}
pp <- ggplot(all_strategies, aes(x = strategy, y = correlation, fill = strategy)) +
  geom_violin(trim = FALSE, scale = "width") + ylim(-1.000001, min + 0.00001) +
  geom_boxplot(width=0.05)+
  theme(axis.text.x = element_blank(), axis.title.x = element_blank()) 
pp

```

```{r methods_comparison_violin_p, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}

cat("\n\nThis plot shows the distributions of correlation P values between RNAseq and miRNAseq using diferent strategies.
  \n")
pp <- ggplot(all_strategies, aes(x = strategy, y = pval, fill = strategy)) +
  geom_violin(trim = FALSE, scale = "width") + ylim(-0.0001, 0.2) +
  geom_boxplot(width=0.05)+
  theme(axis.text.x = element_blank(), axis.title.x = element_blank()) 
pp

```

```{r methods_comparison_bar, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}

cat("\n\n This plot shows how strategies are supported by target databases\n\n")

pp <- ggplot(filters_summary, aes(y = pairs, x = strategy, fill = type)) + 
      geom_bar(stat= "identity",position=position_dodge()) +
      geom_errorbar(aes(ymin=pairs-sdev, ymax=pairs+sdev), width=.2,
                 position=position_dodge(.9)) + 
      theme(axis.text.x = element_text(angle = 20, hjust = 1)) + 
      geom_text(aes(label = pairs), angle = 45, position = position_dodge(width=0.95), size=2, vjust = -2)
pp

filter_stats <- filters_summary[!is.na(filters_summary$p_val), c("strategy", "type", "p_val", "quantile")]
filter_stats <- reshape(filter_stats, timevar="type", idvar="strategy", direction ="wide")
filter_stats$targets <- rep(NA, nrow(filter_stats))
# save(filter_stats, all_strategies, file = file.path(opt$output_files, "debug.RData") )
prevalent_miRNAs <- miRNAseq[["DH_results"]]$gene_name[miRNAseq[["DH_results"]]$genes_tag == "PREVALENT_DEG"]
# save(filter_stats, prevalent_miRNAs, strategies, file = file.path(opt$output_files, "debug.RData"))
for (strategy in unique(filter_stats$strategy)) {
  correlated_pairs <- strategies$all_possible_permutations[strategies[[strategy]]$correlated_pairs, c("miRNAseq", "RNAseq")]
  filter_stats[filter_stats$strategy == strategy, "miRNAs"] <- length(unique(correlated_pairs$miRNAseq))
  filter_stats[filter_stats$strategy == strategy, "targets"] <- length(unique(correlated_pairs$RNAseq))
  filter_stats[filter_stats$strategy == strategy, "DEMs"] <- length(unique(correlated_pairs[correlated_pairs$miRNAseq %in% prevalent_miRNAs, "miRNAseq"]))
  filter_stats[filter_stats$strategy == strategy, "DEMs_targets"] <- length(unique(correlated_pairs[correlated_pairs$miRNAseq %in% prevalent_miRNAs, "RNAseq"]))
}

cat("\n\n This table compare P values and Quantile of pairs discovering by strategy. Targets are unique count of genes that correlated with prevalent differential expression miRNAs\n\n")
knitr::kable(filter_stats, digits = 3, format.args = list(scientific = TRUE))
# datatable(filter_stats, filter = 'top', rownames = FALSE, extensions = c('Buttons','ColReorder'),
#             options = list(
#               paging = FALSE,
#               colReorder = TRUE,
#               dom = 'lftBip',
#               buttons = c('copy', 'csv', 'excel')
#           ))

valid_strats <- filter_stats[filter_stats$p_val.predicted < 0.01 & filter_stats$p_val.validated < 0.01, "strategy"]

```

```{r methods_comparison_intersection, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}


common_pairs <- matrix(,nrow = length(approaches), ncol = length(approaches))

colnames(common_pairs) <- approaches
rownames(common_pairs) <- approaches

for (col_strategy in approaches) {
  strat_pairs <- strategies$all_possible_permutations[all_strategies[all_strategies$strategy == col_strategy, "pair"], c("RNAseq", "miRNAseq")]

  col_pairs <- strat_pairs %>% unite("pairs", RNAseq:miRNAseq, sep = "", na.rm = FALSE)
  col_pairs <- col_pairs$pairs
  for (row_strategy in approaches) {
    strat_pairs <- strategies$all_possible_permutations[all_strategies[all_strategies$strategy == row_strategy, "pair"], c("RNAseq", "miRNAseq")]
    row_pairs <- strat_pairs %>% unite("pairs", RNAseq:miRNAseq, sep = "", na.rm = FALSE)
    row_pairs <- row_pairs$pairs
    common_pairs[row_strategy, col_strategy] <- length(intersect(col_pairs, row_pairs))
  }
}

common_pairs <- as.data.frame(as.table(as.matrix(common_pairs)))

names(common_pairs) <- c("x_axis", "y_axis",  "intersection")

common_pairs$text <- as.character(common_pairs$intersection)
common_pairs$x_axis <- as.character(common_pairs$x_axis)
common_pairs$y_axis <- as.character(common_pairs$y_axis)


# save(common_pairs, file = file.path(output_files, "test.RData"), envir = environment())

pp <- gg_heatmap(data =  common_pairs, 
            x_axis = "x_axis",
            y_axis= "y_axis",
            fill = "intersection",
            text_plot= "text", 
            labs = FALSE)
pp
# q()
# gc()
```

```{r methods_comparison_cor_dist, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}

# cat("\n\nOverlap between the different strategies in terms of miRNA-target gene pairs detected.\n\n")


# distribution_legend <- c()

# plot_grid <- lapply(names(strategies), function(strategy) {
#     signif_distribution <- strategies[[strategy]]$all_pairs_info 

#     cor_distributions <- data.frame(subset = "background", correlation = strategies$dd$all_pairs_info$correlation, stringsAsFactors = FALSE)
#     # save(cor_distributions, signif_distribution, file = file.path(opt$output_files, "debug.RData"))

#     cor_distributions <- rbind(cor_distributions, data.frame(subset = "predicted", 
#                                                               correlation = signif_distribution[signif_distribution$predicted_c > 0,"correlation"]))
#     cor_distributions <- rbind(cor_distributions, data.frame(subset = "validated", 
#                                                               correlation = signif_distribution[signif_distribution$validated_c > 0,"correlation"]))
#     cor_distributions <- rbind(cor_distributions, data.frame(subset = "both", 
#                                                               correlation = signif_distribution[signif_distribution$validated_c > 0 & signif_distribution$predicted_c > 0, "correlation"]))
#     gg <- ggplot(data = cor_distributions, aes(x = correlation, color = subset, fill = subset) ) +
#           ggtitle(strategies[[strategy]]$name) +
#           geom_density(alpha = 0.2, stat = "density") + ylim(0,2) + theme(legend.position = "top")
#     cor_distributions <- NULL
#     return(gg)
# })

# distribution_legend <- extract_legend(plot_grid[[1]])
# plot_grid <- lapply(plot_grid, function(plot){ return(plot + theme(legend.position = "none")) })

# library(grid)
# grid.draw(distribution_legend) 
# grid.arrange(grobs = plot_grid, ncol = 3)

```

```{r roc_curve, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}
#   print(valid_strats)
#   print(roc_data)
# save(valid_strats, roc_data, file = "/mnt/home/users/bio_267_uma/josecordoba/test/test_miRNA-RNA/test.RData")
#     roc_predicted <- roc_data$predicted
#     roc_data$predicted <- NULL
#     roc_validated <- roc_data$validated
#     roc_data$validated <- NULL
#     roc_data <- roc_data[, valid_strats]


#     # roc_data <- as.matrix(roc_data)
#     cat("\n\nROC curve using multiMiR predicted relations as gold standard\n\n")
#     pred_pred <- ROCR::prediction(roc_data, labels = matrix(roc_predicted, nrow = length(roc_predicted), ncol = ncol(roc_data)))
#     perf_roc_pred <- ROCR::performance(pred_pred, "tpr", "fpr")

#     plot(perf_roc_pred, main = "ROC")
#     cat("\n\nPrecision-Recall curve using multiMiR predicted relations as gold standard\n\n")

#     prec_rec_pred <- ROCR::performance(pred_pred, "prec", "rec")
#     plot(prec_rec_pred, main = "PREC-REC")

#     cat("\n\nROC curve using multiMiR validated relations as gold standard\n\n")

#     pred_val <- ROCR::prediction(roc_data, labels = matrix(roc_validated, nrow = length(roc_validated), ncol = ncol(roc_data)))
#     perf_roc_val <- ROCR::performance(pred_val, "tpr", "fpr")
#     plot(perf_roc_val, main = "ROC")  

#     prec_rec_val <- ROCR::performance(pred_val, "prec", "rec")
#     plot(prec_rec_val, main = "PREC-REC")

``` 
```{r all_db_dist, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}
    # cat("\n\nArea under the curve for different strategies using multiMiR predicted and validated pairs as gold standard\n\n")
    # predicted_auc <- ROCR::performance(pred_pred, "auc")
    # predicted_val <- ROCR::performance(pred_val, "auc")
    # all_auc <- data.frame(strategy = colnames(roc_data),
    #                       predicted_auc = unlist(predicted_auc@y.values),
    #                       validated_auc = unlist(predicted_val@y.values)
    #                       )

    # datatable(all_auc, filter = 'top', rownames = FALSE, extensions = c('Buttons','ColReorder'),
    #         options = list(
    #           paging = FALSE,
    #           colReorder = TRUE,
    #           dom = 'lftBip',
    #           buttons = c('copy', 'csv', 'excel')
    #       ))

```
```{r db_distr, results = 'asis', echo = FALSE, warning = FALSE, message = FALSE}
    # warning(str(db_distribution))
    # db_distribution <- db_distribution[db_distribution$strategy %in% valid_strats,]
    
    # db_distribution$strategy <- gsub("_vs_", "_vs\n", db_distribution$strategy)
    gg <- ggplot(db_distribution, aes(y = score, x = strategy, fill = step)) +
    geom_boxplot() + ylim(0, NA) + theme(axis.text.x = element_text(angle = 20, hjust = 1))

    plot(gg)
   # aux <- db_distribution %>% group_by(strategy, step) %>% summarize(Count = n())
    dist_pval <- data.frame()
    for (strategy in unique(db_distribution$strategy)) {
      true_dis <- db_distribution[db_distribution$strategy == strategy & db_distribution$step == "predicted", "score"]
      rand_dis <- db_distribution[db_distribution$strategy == strategy & db_distribution$step == "predicted_random", "score"] 
      # str(true_dis)
      # message(length(res))
      # print(c(nrow(true_dis), nrow(rand_dis)))
      if(nrow(true_dis) != 0 ){
        res <- MKinfer::boot.t.test(true_dis, y = rand_dis, alternative = "greater" )
        res <- res$boot.p.value
      } else {
        res <- 1
      }
      tem_pval <- data.frame(strategy = strategy, dist_pvalue = res)
      dist_pval <- rbind(dist_pval, tem_pval)
    }

```
```{r db_distr_table, results = 'asis', echo = FALSE, warning = FALSE, message = FALSE}
   knitr::kable(dist_pval, format.args = list(scientific = TRUE))

```
```{r str_diff_predicted, results = 'asis', echo = FALSE, warning = FALSE, eval = FALSE}
  cat("\n\nmiRNA-targets pairs \n\n")
  venn_data <- lapply(valid_strats, function(strategy){
    strat_significant_pairs <- all_strategies$strategy == strategy & all_strategies$predicted_c > 0

    pairs <- strategies$all_possible_permutations[all_strategies[strat_significant_pairs, "pair"], c("RNAseq", "miRNAseq")] #<- paste0(all_strategies[strat_significant_pairs, "miRNAseq"], all_strategies[strat_significant_pairs, "RNAseq"])
    pairs <- pairs %>% unite("pair", RNAseq:miRNAseq, sep = "", na.rm = FALSE) 
    pairs <- unique(pairs$pairs)
    return(pairs)
    })
  names(venn_data) <- valid_strats
  grid::grid.draw(venn.diagram(x = venn_data,
  filename = NULL))
```

```{r str_diff_mirna, results = 'asis', echo = FALSE, warning = FALSE,  eval = FALSE}
  cat("\n\nmiRNA shared\n\n")

  venn_data <- lapply(valid_strats, function(strategy){
    strat_significant_pairs <- all_strategies$strategy == strategy & all_strategies$predicted_c > 0

    miRNA_ID <- unique(strategies$all_possible_permutations[all_strategies[strat_significant_pairs, "pair"], "miRNAseq"])
    return(miRNA_ID)
    })
  names(venn_data) <- valid_strats
  grid::grid.draw(venn.diagram(x = venn_data,
  filename = NULL))
```
```{r str_diff_target, results = 'asis', echo = FALSE, warning = FALSE,  eval = FALSE}
  cat("\n\ntargets shared\n\n")

  venn_data <- lapply(valid_strats, function(strategy){
    strat_significant_pairs <- all_strategies$strategy == strategy & all_strategies$predicted_c > 0

    RNA_ID <- unique(strategies$all_possible_permutations[all_strategies[strat_significant_pairs, "pair"], "RNAseq"])
    return(RNA_ID)
    })
  names(venn_data) <- valid_strats
  grid::grid.draw(venn.diagram(x = venn_data,
  filename = NULL))
```

```{r prec_rec, echo=FALSE, results = 'asis', warning = FALSE, message = FALSE}
    
    # prec_recall <- prec_recall[prec_recall$strategy %in% valid_strats,]
    prec_recall$gold_standard <- factor(prec_recall$gold_standard, levels=c("predicted","validated","both"))

    for (metric in c("precision", "recall", "F1")) {
      gg <- ggplot(prec_recall, aes(x = strategy, y = prec_recall[,metric], fill = gold_standard))+
      geom_bar(stat= "identity",position=position_dodge()) + 
      ggtitle(metric) + theme(axis.text.x = element_text(angle = 20, hjust = 1))
      cat(paste0("\n\n",metric," comparison for strategies\n\n"))
      plot(gg)
    }


```


```{r render_partial_reports, echo = FALSE, warning = FALSE}
  curr_out <- ""

  curr_out <- unlist(lapply(approaches ,function(method_name){
      sec_text <- paste(c("## **", method_name ," correlation method**\n"),collapse="") # Header
      sec_text <- c(sec_text, knit_expand("partial/miRNA_cor_methods.Rmd")) # Body
      return(sec_text)
  }))    
# save(list = ls(all.names = TRUE), file = file.path(opt$output_files, "debug.RData"), envir = environment())

``` 

`r paste(knit(text = curr_out), collapse = '\n')`



